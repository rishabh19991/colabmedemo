'use strict';var ColabApp = angular.module('app');ColabApp.controller('SignCtrl', function($scope,$state,Account) {  $scope.sign = function() {	if($scope.newAccount){		if(!$scope.newAccount.name){			$scope.Nameerror = true;			return false;		}		if(!$scope.newAccount.email){			$scope.Emailerror = true;			return false;		}		if(!$scope.newAccount.password){			$scope.passworderror = true;			return false;		}					Account.create({			'username': $scope.newAccount.name,			'email': $scope.newAccount.email,			'password': $scope.newAccount.password		  }, function (newAccount) {			$scope.newAccount.name = '';			$scope.newAccount.email = '';			$scope.newAccount.password = '';			alert('You have successfully registered with colabme. Please login using your credentials');			$state.go('login');		  }, function  (err) {			console.log(err);		  });	}  };}).controller('LoginCtrl',function($scope,$state,$stateParams,Account,LoopBackAuth) {  $scope.login = function() {  	var TWO_WEEKS = 1000*60*60*24*7*2;  	Account.login({  	 	'email': $scope.account.email,        'password': $scope.account.password,        'ttl': TWO_WEEKS  	  }).$promise.then(function (accessToken) {  	  		LoopBackAuth.accessTokenId = accessToken.id;  	  		LoopBackAuth.currentUserId = accessToken.userId;  	  		LoopBackAuth.rememberMe = true;  	  		LoopBackAuth.save();  	 		$state.go('dashboard',{currentUserId: LoopBackAuth.currentUserId});  	  	},  function (err) {			alert('Wrong email or password');			console.log(err.statusText);  	  	});  };}).controller('imageUploadCtrl', function($scope,$state,$stateParams, $cookies) {		alert('Inside Image uploader');}).controller('sharedMoodboardCtrl', function($scope,$state,$stateParams, $cookies) {	$scope.moodboardId = $stateParams.moodboardId;	$cookies.moodboardId = $stateParams.moodboardId;}).controller('newMoodboardCtrl', function($scope,$state,$stateParams,$cookies,Account,Moodboard,MoodboardService,AccountService,LoopBackAuth) {	$scope.selectedUsers={};	$scope.userAccount={};	$scope.selectedUsers.items = [];	$scope.currentUserId = LoopBackAuth.currentUserId;	$scope.currentUserId = $stateParams.currentUserId;	$scope.moodboardId = $cookies.moodboardId;	$scope.moodboards = MoodboardService.moodboards;	$scope.moodboadImages = MoodboardService.moodboadPageImages;	MoodboardService.getMoodboards($stateParams.currentUserId);	$scope.userAccounts = AccountService.accounts;	AccountService.getAccounts();		//For getting all users	$scope.selectedUsers={};	$scope.userAccounts = AccountService.accounts;	//var userMailsString = $scope.moodboardAccount.email;	//FOr all availableusers	function createselectedUsers (userMailsString) {		var userMailsArray = userMailsString.split(', ');		var selectedUsers = {			id: [],			isError: false		};		var avaibleUsers = [];		var avaibleIds = [];		console.log($scope.userAccounts);		for (var i = 0; i < $scope.userAccounts.length; i++) {			avaibleUsers.push($scope.userAccounts[i].email);			avaibleIds.push($scope.userAccounts[i].id);		}		for ( i = 0; i < userMailsArray.length; i++) {			if(avaibleUsers.indexOf(userMailsArray[i]) > -1){				selectedUsers.id.push(avaibleIds[avaibleUsers.indexOf(userMailsArray[i])]);			} else{			//	alert('There is no such user ' + userMailsArray[i]);				selectedUsers.isError = true;				selectedUsers.id.push(userMailsArray[i]);			}		}		return selectedUsers;  }  $scope.sign = function() {	var selectedUsers = createselectedUsers($scope.newAccount.email);	if(selectedUsers){			if(selectedUsers.isError){				for (var i = 0; i < selectedUsers.id.length; i++) {					var password = $scope.newAccount.password;					Account.create({'email': selectedUsers.id[i], 'password': password}, function(response){												Moodboard.prototype$__link__accounts({'id': $scope.moodboardId,'fk':response.id}, {});					})				}				$state.go('login');			}			else{				alert('User with this email already Exist. Please login using your credentials');			}		}	}		$scope.login = function() {  	var TWO_WEEKS = 1000*60*60*24*7*2;  	Account.login({  	 	'email': $scope.account.email,        'password': $scope.account.password,        'ttl': TWO_WEEKS  	  }).$promise.then(function (accessToken) {  	  		LoopBackAuth.accessTokenId = accessToken.id;			console.log(LoopBackAuth.accessTokenId);  	  		LoopBackAuth.currentUserId = accessToken.userId;  	  		LoopBackAuth.rememberMe = true;  	  		LoopBackAuth.save();  	  	},  function (err) {			alert('Wrong email or password');  	  	});  };}).controller('updateProfileCtrl', function($scope,$state,$stateParams,$cookies,Account,Moodboard,MenuService,AccountService,MoodboardService,LoopBackAuth) {	MenuService.activeMenuButton();	$scope.selectedUsers={};	$scope.userAccount={};	$scope.updateprofile={};	$scope.currentuserMail = '';	$scope.currentuserID = '';	$scope.selectedUsers.items = [];		$scope.currentUserId = LoopBackAuth.currentUserId;	//$scope.currentUserId = $stateParams.currentUserId;	$scope.moodboardId = $stateParams.moodboardId;	$cookies.moodboardId = $stateParams.moodboardId;	$scope.moodboards = MoodboardService.moodboards;	$scope.moodboadImages = MoodboardService.moodboadPageImages;	MoodboardService.getMoodboards($stateParams.currentUserId);	$scope.userAccounts = AccountService.accounts;	AccountService.getAccounts();		//Displaying Account Data 	$scope.ProfileView = function() {		Account.findById({'id': $scope.currentUserId}).$promise.then(function(res){			console.log(res);			$scope.updateprofile.name = res.fullname;			$scope.updateprofile.email = res.email;		});	}	//For updating existing user	$scope.updateProfile = function() {		if($scope.updateprofile.email){			if($scope.updateprofile.pass && $scope.updateprofile.cpass) {				if($scope.updateprofile.pass != $scope.updateprofile.cpass) {					$scope.showError = true;					return;				}				else {					Account.prototype$updateAttributes({'id': LoopBackAuth.currentUserId}, {'username': $scope.updateprofile.name, 'email': $scope.updateprofile.email, 'password': $scope.updateprofile.pass}).$promise.then(function(){						alert('Profile Updated!. Please login again');						AccountService.logout();						$state.go('login');										});				}			}			else {				Account.prototype$updateAttributes({'id': LoopBackAuth.currentUserId}, {'email': $scope.updateprofile.email}).$promise.then(function(){					alert('Profile Updated!');					$state.go('dashboard', {currentUserId: LoopBackAuth.currentUserId});				});			}		}		else{			alert('Email is required');		}	}}).controller('DashboardCtrl', function($rootScope,$scope,$state,$stateParams,$cookies,Account,Moodboard,MenuService,AccountService,MoodboardService,LoopBackAuth) {	MenuService.activeMenuButton();	$scope.selectedUsers={};	$scope.userAccount={};	$scope.updateprofile={};	$scope.currentuserMail = '';	$scope.currentuserID = '';	$scope.selectedUsers.items = [];		$scope.currentUserId = LoopBackAuth.currentUserId;	//$scope.currentUserId = $stateParams.currentUserId;	$scope.moodboardId = $stateParams.moodboardId;	$cookies.moodboardId = $stateParams.moodboardId;	$scope.moodboards = MoodboardService.moodboards;	$scope.moodboadImages = MoodboardService.moodboadPageImages;	MoodboardService.getMoodboards($stateParams.currentUserId);	$scope.userAccounts = AccountService.accounts;	AccountService.getAccounts();	$scope.section = 1;		Account.findById({'id': $scope.currentUserId}).$promise.then(function(res){		$cookies.currentUserName = res.username;	});	//Sending mails to users	function linkMailsToUsersId (userMailsString) {		var userMailsArray = userMailsString.split(', ');		var selectedUsers = {			id: [],			isError: false		};		var avaibleUsers = [];		var avaibleIds = [];		for (var i = 0; i < $scope.userAccounts.length; i++) {			avaibleUsers.push($scope.userAccounts[i].email);			avaibleIds.push($scope.userAccounts[i].id);		}		for ( i = 0; i < userMailsArray.length; i++) {			if(avaibleUsers.indexOf(userMailsArray[i]) > -1){				selectedUsers.id.push(avaibleIds[avaibleUsers.indexOf(userMailsArray[i])]);			} else{			//	alert('There is no such user ' + userMailsArray[i]);				selectedUsers.isError = true;				selectedUsers.id.push(userMailsArray[i]);			}		}		return selectedUsers;	}		//Adding moodboard & sending mail to all invited users	$scope.addMoodboard = function () {		//Checking for client side authentication		if($scope.newMoodboard.userMails){			var selectedUsers = linkMailsToUsersId($scope.newMoodboard.userMails);		}		else{			alert("Enter your friend's email");		}		if(selectedUsers){				Account.prototype$__create__moodboards({'id': LoopBackAuth.currentUserId}, $scope.newMoodboard).$promise.then(function (mood) {				if(selectedUsers.isError){					for (var i = 0; i < selectedUsers.id.length; i++) {						var password = selectedUsers.id[i].slice(0,4) + '@colabme';						Account.create({'email': selectedUsers.id[i], 'password': password}, function(response){							Moodboard.prototype$__link__accounts({'id': mood.id,'fk':response.id}, {});						})					}					$state.go('dashboard',{currentUserId: LoopBackAuth.currentUserId});				}				else {						Account.prototype$__create__moodboards({'id': LoopBackAuth.currentUserId}, $scope.newMoodboard).$promise.then(function (mood) {		  	 			for (var i = 0; i < selectedUsers.id.length; i++) {		  	 				Moodboard.prototype$__link__accounts({'id': mood.id,'fk':selectedUsers.id[i]}, {});		  	 			}						$scope.newMoodboard = '';						$state.go('dashboard',{currentUserId: LoopBackAuth.currentUserId});					});				}			})		}	}	//Displaying moodboard to the authenticated users	$scope.showMoodboard = function(moodboardId) {		$state.go('moodboard',{currentUserId: LoopBackAuth.currentUserId, moodboardId: moodboardId});	};	//Deleting moodboard	$scope.deleteMoodboard = function(moodboardId) {		MoodboardService.deleteMoodboard(moodboardId,$stateParams.currentUserId);	};	//Logging you out from the moodboard	$scope.logOut = function() {		$cookies = {};		AccountService.logout();	};}).controller('TasksCtrl',function($scope,$state,$stateParams,Account,Moodboard,Task,LoopBackAuth,AccountService,MenuService,TaskService) {	$scope.currentUserId = LoopBackAuth.currentUserId;	$scope.pageId = $stateParams.pageId;	MenuService.activeMenuButton();		//Displaying Account Data 	$scope.ProfileView = function() {		Account.findById({'id': $scope.currentUserId}).$promise.then(function(res){			$scope.updateprofile.email = res.email;		});	}		//For updating existing user	$scope.updateProfile = function() {		if($scope.updateprofile.email){			if($scope.updateprofile.pass && $scope.updateprofile.cpass) {				if($scope.updateprofile.pass != $scope.updateprofile.cpass) {					$scope.showError = true;					return;				}				else {					Account.prototype$updateAttributes({'id': LoopBackAuth.currentUserId}, {'email': $scope.updateprofile.email, 'password': $scope.updateprofile.pass}).$promise.then(function(){						alert('Profile Updated!. Please login again');						AccountService.logout();						$state.go('login');										});				}			}			else {				Account.prototype$updateAttributes({'id': LoopBackAuth.currentUserId}, {'email': $scope.updateprofile.email}).$promise.then(function(){					alert('Profile Updated!');					$state.go('dashboard', {currentUserId: LoopBackAuth.currentUserId});				});			}		}		else{			alert('Email is required');		}	}		//Getting moodboards for the particular user	$scope.getMoodboards = function() {		Account.prototype$__get__moodboards({'id': LoopBackAuth.currentUserId}).$promise.then(function (moodboards) {			$scope.moodboards = moodboards;			$scope.pagesAll = [];			for (var i = 0; i < $scope.moodboards.length; i++) {				if (Object.keys($scope.moodboards[i]).length){					Moodboard.prototype$__get__pages({'id': $scope.moodboards[i].id}).$promise.then(function(pages) {						$scope.pagesAll.push({'pages': pages});					 });				}			}		});	};	//calling moodboards at load instance	$scope.getMoodboards();	$scope.tasks = TaskService.tasks;	TaskService.getTasks();	//Updating state of task using checkboxes value	$scope.updateTaskState = function(taskId, state) {		TaskService.updateTaskState(taskId, state);	};	//Logging you out from the moodboard	$scope.logOut = function() {		AccountService.logout();	};}).controller('MoodboardCtrl', function($scope,$location,$state,$stateParams,Account,Moodboard,Task,AccountService,MenuService,MoodboardService,PageService,LoopBackAuth) {	MenuService.activeMenuButton();	$scope.currentUserId = LoopBackAuth.currentUserId;	$scope.moodboard = MoodboardService.moodboard;	MoodboardService.getMoodboard($stateParams.moodboardId);	$scope.pages = PageService.pages;	PageService.getPages($stateParams.moodboardId);		//Displaying Account Data 	$scope.ProfileView = function() {		Account.findById({'id': $scope.currentUserId}).$promise.then(function(res){			console.log(res);			console.log(res.email);			$scope.updateprofile.id = res.id;			$scope.updateprofile.email = res.email;		});	}		//For updating existing user	$scope.updateProfile = function() {		if($scope.updateprofile.email){			if($scope.updateprofile.pass && $scope.updateprofile.cpass) {				if($scope.updateprofile.pass != $scope.updateprofile.cpass) {					$scope.showError = true;					return;				}				else {					Account.prototype$updateAttributes({'id': LoopBackAuth.currentUserId}, {'email': $scope.updateprofile.email, 'password': $scope.updateprofile.pass}).$promise.then(function(){						alert('Profile Updated!. Please login again');						AccountService.logout();						$state.go('login');										});				}			}			else {				Account.prototype$updateAttributes({'id': LoopBackAuth.currentUserId}, {'email': $scope.updateprofile.email}).$promise.then(function(){					alert('Profile Updated!');					$state.go('dashboard', {currentUserId: LoopBackAuth.currentUserId});				});			}		}		else{			alert('Email is required');		}	}		//Displaying page for the moodboard	$scope.showPage = function (pageId) {		$stateParams.pageId = pageId;		$state.go('page',{currentUserId: LoopBackAuth.currentUserId, moodboardId: $stateParams.moodboardId, pageId: pageId});	};	//Adding new page to the moodboard	$scope.addPage = function () {		var data = {		  'name': 'Your page`s name',		  'data': ' '		};		PageService.createPage(LoopBackAuth.currentUserId, $stateParams.moodboardId, data);	};	//Deleting an existing page using page Id	$scope.deletePage = function (pageId) {		PageService.deletePage($stateParams.moodboardId,pageId);	};	//Logging you out from the moodboard	$scope.logOut = function() {		AccountService.logout();	};}).controller('PageCtrl',function($scope,$location,$state,$stateParams,Account,Moodboard,Task,AccountService,MenuService,MoodboardService,PageService,TaskService,LoopBackAuth, $modal) {	var loadUrl = false;	MenuService.activeMenuButton();		$scope.pageId = $stateParams.pageId;	$scope.currentUserId = LoopBackAuth.currentUserId;	var isChange = false;	$scope.shareMoodboard = function () {		var UrlPath = $location.absUrl();		var baseLen = 'http://'+ $location.host() +'/api/Moodboard/' + $stateParams.moodboardId + '/pages/' + $stateParams.pageId;		var modalInstance = $modal.open({		  template: '<div class=""><div class="modal-content"><div class="modal-header">Colab<b>me</b></div><div class="modal-body">Below is the shared link for the moodboard.<br/><b>'+baseLen+'<b><br/>You can go to this link by Clicking <b><a style="text-align:center" href="'+baseLen+'" target="_blank">Share Link</a></b></div><div class="modal-footer"><button type="button" class="btn btn-default" data-dismiss="modal" ng-click="cancel()">Close</button></div></div></div>',		  controller: 'ModalInstanceCtrl'		});	};		$scope.exportMoodboard = function() {		html2canvas($(".workflow"), {            onrendered: function(canvas) {                         var imgData = canvas.toDataURL('image/png', 5.0);                              var doc = new jsPDF('p', 'mm');                doc.addImage(imgData, 'PNG', 10, 10, 300, 200);                doc.save('sample.pdf');            }        });	};		$scope.addnewImage = function(image) {		var filesInput = document.getElementById("inputImage");		filesInput.addEventListener("change", function(event){             var files = event.target.files; //FileList object			var position = $(".toolbar").position();			Workflow.prototype.addImage(files, position.left, position.top);		});	}		$scope.zoomScroller = function() {		var zoomLev = 1.2;		var workflowDiv = document.getElementById("newworkflow");		if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {			workflowDiv.addEventListener("DOMMouseScroll", function(event){				if(event){					if(event.detail){						if(event.detail /120 > 0) {							// if (typeof (document.getElementById('newworkflow').style.zoom) != "undefined") {								// $(document.getElementById('newworkflow')).css('zoom', zoomLev);								// if(zoomLev == 1.2)									// zoomLev = zoomLev - 0.2;								// else									// zoomLev = zoomLev - 0.1;							// }							for(var i=0; i< $('.img_wrapper').length; i++){								if(parseInt($('.img_wrapper')[i].style.width) > 250 && parseInt($('.img_wrapper')[i].style.height) > 200)									$('.img_wrapper').css({'width': parseInt($('.img_wrapper')[i].style.width) - 80, 'height': parseInt($('.img_wrapper')[i].style.height) - 80});							}													for(var i=0; i< $('.editor').length; i++){								if(parseInt($('.editor')[i].style.fontSize) > 16)									$('.editor').css({'font-size': parseInt($('.editor')[i].style.fontSize) - 5});							}						}						else {								// Mozilla doesn't support zoom, use -moz-transform to scale and compensate for lost width								// $('#newworkflow').css({									// "-moz-transform": 'scale(' + zoomLev + ')',									// width: $(window).width() / zoomLev								// });								// if(zoomLev == 1.2)									// zoomLev = zoomLev - 0.2;								// else									// zoomLev = zoomLev - 0.1;							for(var i=0; i< $('.img_wrapper').length; i++){								if(parseInt($('.img_wrapper')[i].style.width) < 600)									$('.img_wrapper').css({'width': parseInt($('.img_wrapper')[i].style.width) + 70, 'height': parseInt($('.img_wrapper')[i].style.height) + 70});							}											for(var i=0; i< $('.editor').length; i++){								if(!$('.editor')[i].style.fontSize)									$('.editor').css({'font-size': '20px'});								if(parseInt($('.editor')[i].style.fontSize) < 70)									$('.editor').css({'font-size': parseInt($('.editor')[i].style.fontSize) + 5});							}						}					}				}			});		}		workflowDiv.addEventListener("mousewheel", function(event){ 			if(event){				if(event.wheelDelta){					if(event.wheelDelta /120 > 0) {						for(var i=0; i< $('.img_wrapper').length; i++){							if(parseInt($('.img_wrapper')[i].style.width) < 600)								$('.img_wrapper').css({'width': parseInt($('.img_wrapper')[i].style.width) + 70, 'height': parseInt($('.img_wrapper')[i].style.height) + 70});						}												for(var i=0; i< $('.editor').length; i++){							if(!$('.editor')[i].style.fontSize)								$('.editor').css({'font-size': '20px'});							if(parseInt($('.editor')[i].style.fontSize) < 70)								$('.editor').css({'font-size': parseInt($('.editor')[i].style.fontSize) + 5});						}					}					else {						for(var i=0; i< $('.img_wrapper').length; i++){							if(parseInt($('.img_wrapper')[i].style.width) > 250 && parseInt($('.img_wrapper')[i].style.height) > 200)								$('.img_wrapper').css({'width': parseInt($('.img_wrapper')[i].style.width) - 80, 'height': parseInt($('.img_wrapper')[i].style.height) - 80});						}												for(var i=0; i< $('.editor').length; i++){							if(parseInt($('.editor')[i].style.fontSize) > 16)								$('.editor').css({'font-size': parseInt($('.editor')[i].style.fontSize) - 5});						}					}				}			}		});	};		$scope.checkForChanges = function(state) {	  $state.go(state,{currentUserId: LoopBackAuth.currentUserId});	};	$scope.tasks = TaskService.tasks;	TaskService.getTasks();	$scope.updateTaskState = function(taskId, state) {		TaskService.updateTaskState(taskId, state);	};	$scope.showTaskForm = function() {		$scope.showTask = true;		$scope.userAccount = {};		$scope.userAccounts = MoodboardService.moodboardAccounts;		MoodboardService.getMoodboardAccounts($stateParams.moodboardId);	};	$scope.addTask = function() {			console.log('Description - ' + $scope.taskDescription + '<br/> Selected Id - ' + $scope.userAccount.selected.id + '<br/> PageId - ' + $scope.pageId);		TaskService.addTask($scope.taskDescription,$scope.userAccount.selected.id,$scope.pageId);		$scope.taskDescription = '';		$scope.showTask = false;	};	var showPage = function(pageId) {		Moodboard			.prototype$__findById__pages({'id': $stateParams.moodboardId, 'fk': pageId})			.$promise			.then(function (page) {		 		$scope.pageName = page.name;				debugger;		 		var wf = $('.workflow');		 			wf.html(page.data);		 			if (!wf.children().length){		 				wf.addClass('bg');		 			}		 		wf.find('.editor').each(function() {		  			var editor = new WYSIWYG($(this));		  			area.editors.push(editor);					area.makeEditable();					area.checkEditor($(this));		  			editor.initWYSIWYG();					$(this).draggable().resizable({handles: 'ne, se, sw, nw'});		  			$(this).on('keydown', function() {						isChange = true;		  			});					$(this).attr('contenteditable', false);		 		});		 		wf.find('.img_wrapper').each(function(){		  			$(this).draggable().resizable({handles: 'ne, se, sw, nw'});				});				wf.find('.editor').each(function(){				  	$(this).draggable().resizable({handles: 'ne, se, sw, nw'});				});			 		wf.on('dragstop resizestop', '.editor', function() {		  			isChange = true;					pageUpdate();		 		});		 				 		wf.on('dragstop resizestop', '.img_wrapper', function() {		  			isChange = true;		  			pageUpdate();		 		});								wf.on('click', '.img_wrapper', function(){					$('.newClass').removeClass('newClass');					$(this).addClass('newClass');					$('.newClass .hidden').removeClass('hidden');				});								wf.on('click', '.removeimg', function(){					var theAnswer = confirm("Are you sure you want to delete this image?");					if (theAnswer){						 $(this).parent().remove();					  }				});		});	};	showPage($stateParams.pageId);	function pageUpdate () {		if (isChange){	 	var wf = $('.workflow');	 	wf.find('.img_wrapper').each(function(){	 		if( !$(this).is('.ui-draggable') ){	 			$(this).draggable();	 			$(this).resizable({handles: 'ne, se, sw, nw'});	 		}			  $(this).draggable('disable');			  $(this).resizable('destroy');		});		wf.find('.editor').each(function(){			if( !$(this).is('.ui-draggable') ){				$(this).draggable();				$(this).resizable({handles: 'ne, se, sw, nw'});			}			$(this).draggable('disable');			$(this).resizable('destroy');		});	 	var data = {	  	'name': $scope.pageName,	  	'data': wf.html()	  	};	  PageService.updatePage(LoopBackAuth.currentUserId, $stateParams.moodboardId, $stateParams.pageId, data);	  wf.find('.editor').each(function(){	    $(this).resizable({handles: 'ne, se, sw, nw'});	    $(this).draggable('enable');	  });	  wf.find('.img_wrapper').each(function(){	    $(this).resizable({handles: 'ne, se, sw, nw'});	    $(this).draggable('enable');	  });	  isChange = false;	  }	}		$scope.logOut = function() {		AccountService.logout();	};		function WYSIWYG (editor){			this.editor = $(editor);			this.options = {				toolbarSelector: '[data-role=editor-toolbar]',				commandRole: 'edit',				activeToolbarClass: 'active',				activeToolbarBtnClass: 'info',				fontSize: '3'			};			this.toolbarBtnSelector = 'a[data-' + this.options.commandRole + ']';		}		WYSIWYG.prototype.updateToolbar = function() {			var obj = this;			if (obj.options.activeToolbarBtnClass) {				$(obj.options.toolbarSelector).find(obj.toolbarBtnSelector).each(function () {					var command = $(this).data(obj.options.commandRole);					if (document.queryCommandState(command)) {						$(this).addClass(obj.options.activeToolbarBtnClass);					} else {						$(this).removeClass(obj.options.activeToolbarBtnClass);					}				});			}		};		WYSIWYG.prototype.execCommand = function(commandWithArgs) {			var commandArr = commandWithArgs.split(' '),				command = commandArr.shift(),				arg = commandArr.join(' ');				if (arg == 'i') { if (this.options.fontSize == '7') { this.options.fontSize = '7'} else {this.options.fontSize++; document.execCommand(command, 0, this.options.fontSize);} };				if (arg == 'd') { if (this.options.fontSize == '1') { this.options.fontSize = '1'} else {this.options.fontSize--; document.execCommand(command, 0, this.options.fontSize);} };			document.execCommand(command, 0, arg);			this.updateToolbar();		};		WYSIWYG.prototype.bindToolbar = function(toolbar, options) {			var obj = this;			toolbar.find(obj.toolbarBtnSelector).off('mousedown').on('mousedown', function(event) {				event.preventDefault();				var activeEditor = document.activeElement;				var selection = window.getSelection();				var range = document.createRange();				if (selection.rangeCount){				 range = selection.getRangeAt(0);				 if (!range.collapsed){				  obj.execCommand($(this).data(obj.options.commandRole));				  return;				 }				} 				range.selectNodeContents(activeEditor);				selection.removeAllRanges();				selection.addRange(range);				obj.execCommand($(this).data(obj.options.commandRole));				obj.editor.focus();			});		};		WYSIWYG.prototype.setToolbarPosition = function(toolbar) {			var obj = this;			var posEditor = obj.editor.position();			toolbar.css({				'left': posEditor.left + 50,				'top': posEditor.top - 50			});		};		WYSIWYG.prototype.initWYSIWYG = function() {			var obj = this;						var toolbar = $(obj.options.toolbarSelector);			this.bindToolbar(toolbar, this.options);			this.editor.keypress(function(event) {				if (event.which != 13)					return true;				var docFragment = document.createDocumentFragment();				//add a new line				var newEle = document.createTextNode('\n');				docFragment.appendChild(newEle);				//add the br, or p, or something else				newEle = document.createElement('br');				docFragment.appendChild(newEle);				//make the br replace selection				var range = window.getSelection().getRangeAt(0);				range.deleteContents();				range.insertNode(docFragment);				//create a new range				range = document.createRange();				range.setStartAfter(newEle);				range.collapse(true);				//make the cursor there				var sel = window.getSelection();				sel.removeAllRanges();				sel.addRange(range);				return false;			});			this.editor.on('keyup mousemove', function (event) {				obj.setToolbarPosition(toolbar);				obj.updateToolbar();				if (obj.editor.is('[contenteditable="true"]')) { toolbar.addClass(obj.options.activeToolbarClass); } 					else { toolbar.removeClass(obj.options.activeToolbarClass); }			});			this.editor.focus();		};		// WYSIWYG end		 		// Workflow start		function Workflow (selector){						this.selector = $(selector);			this.editors = [];			this.areaOffset = this.selector.offset();		}		Workflow.prototype = Object.create(WYSIWYG.prototype);		Workflow.prototype.setEditorPosition = function(editor, posX, posY) {			editor.css({				'left': posX,				'top': posY			});		};		Workflow.prototype.work = function() {			var obj = this;						obj.selector.on('click', function(event) {				if (event.target != this) { return; }								$('.newClass').removeClass('newClass');								$('.removeimg').addClass('hidden');								$(this).addClass('disabled_bg');				var editor = $('<p/>').addClass('editor').appendTo(this).attr('contenteditable', true);				var Editor = new WYSIWYG(editor);				Editor.initWYSIWYG();				obj.setEditorPosition(editor, event.clientX - obj.areaOffset.left, event.clientY - obj.areaOffset.top);				obj.editors.push(Editor);				obj.checkEditor(editor);				obj.makeEditable();				isChange = true;			});						obj.bindArea();		};		Workflow.prototype.checkEditor = function(editor) {			var obj = this;			var toolbar = $('.toolbar');			obj.selector.on('click', function (event) {				if ( event.target == this && !editor.text().length ){					editor.remove();					if ( !$(this).children().is('p,img') ){						$(this).removeClass('disabled_bg');					}				}				if( (event.target == this) && (event.target != toolbar) ){					editor.attr('contenteditable', false);					toolbar.removeClass('active');					pageUpdate();				}			});		};		Workflow.prototype.makeEditable = function() {			var obj = this;			$.each(obj.editors, function (index, value){				value.editor.on('dblclick', function() {					$(this).attr('contenteditable', true);					$(this).draggable('disable');					$(this).resizable('disable');					$(this).focus();				});			});		};		Workflow.prototype.bindArea = function() {						var obj = this;						obj.selector.bind({			  dragenter: function() {					$(this).addClass('disabled_bg');			    return false;			  },			  dragover: function() {			    return false;			  },			  dragleave: function() {			  	if ( !$(this).children().is('p,img') ){			  		$(this).removeClass('disabled_bg');			  	}			    return false;			  },			  drop: function(e) {			    var dt = e.originalEvent.dataTransfer,			    				 posX = e.originalEvent.pageX - obj.areaOffset.left,			    				 posY = e.originalEvent.pageY - obj.areaOffset.top;		    	isChange = true;			    obj.addImage(dt.files, posX, posY);			    return false;			  }			});		};		Workflow.prototype.addImage = function(files, posX, posY) {					var obj = this;			if(!obj.selector){				obj.selector = $('.workflow');			}		  $.each(files, function(i, file) {      		    if (!file.type.match(/image.*/)) {		      return true;		    }					    var img_wrapper = $('<p/>').addClass('img_wrapper').appendTo(obj.selector);					    img_wrapper.resizable({handles: 'ne, se, sw, nw'}).draggable();		    var img = $('<img/>').addClass('image').appendTo(img_wrapper);			var removeimg = $('<button/>').addClass('removeimg hidden').appendTo(img_wrapper);			var i = $('<i/>').addClass('fa fa-times').appendTo(removeimg);		    img_wrapper.get().file = file;		 					    var reader = new FileReader();		    reader.onload = (function(aImg,aDiv) {		      return function(e) {				var width = aImg.width();				var height = aImg.height();				if(width < 100)					width = '250';				if(height < 100)					height = '150';		        aImg.attr('src', e.target.result);		    		aDiv.css({'width': width, 'height': height, 'left': posX - width/2, 'top': posY - height/2});					isChange = true;		  			pageUpdate();		      };		    })(img,img_wrapper);		    reader.readAsDataURL(file);		  });		};		// Workflow end		var area = new Workflow('.workflow');		area.work();}).controller('ModalInstanceCtrl', function ($scope, $modalInstance) {  $scope.ok = function () {    $modalInstance.close();  };  $scope.cancel = function () {    $modalInstance.dismiss('cancel');  };}).controller('ChatCtrl', function($rootScope, $scope, $cookies, $location, PubNub, $modal, $stateParams, MoodboardService, LoopBackAuth) {  	$scope.addTask = function(message){		$scope.chatMessageforTask = message.split(']')[1];		$scope.userAccounts = MoodboardService.moodboardAccounts;		MoodboardService.getMoodboardAccounts($stateParams.moodboardId);		$scope.currentUserId = LoopBackAuth.currentUserId;		console.log($scope.userAccounts);		var modalInstance = $modal.open({		  templateUrl: 'js/app/templates/addchattask.html',		  resolve: {			message: function(){				return $scope.chatMessageforTask			},			pageId: function() {				return $stateParams.pageId			},			userAccounts: function() {				return $scope.userAccounts			}		  },		  controller: 'AddChatTaskCtrl'		});	}		$scope.join = function() {	var _ref2;      $rootScope.data || ($rootScope.data = {});      $rootScope.data.username = $cookies.currentUserName;      //$rootScope.data.city = (_ref1 = $scope.data) != null ? _ref1.city : void 0;      $rootScope.data["super"] = (_ref2 = $scope.data) != null ? _ref2["super"] : void 0;      $rootScope.data.uuid = Math.floor(Math.random() * 1000000) + '__' + $cookies.currentUserName;      $rootScope.secretKey = $scope.data["super"] ? 'sec-c-YTQ4OWVhY2MtMDczMy00NmM3LTg4NzQtOWEyMmQ5ZjBlZWE2' : null;      $rootScope.authKey = $scope.data["super"] ? 'ChooseABetterSecret' : null;      PubNub.init({        subscribe_key: 'sub-c-f5a62200-c734-11e4-b4c5-02ee2ddab7fe',        publish_key: 'pub-c-4a83faa8-48c2-45ce-b697-defd92b63fca',        secret_key: $rootScope.secretKey,        auth_key: $rootScope.authKey,        uuid: $rootScope.data.uuid,        ssl: true      });      if ($scope.data["super"]) {        /* Grant access to the SuperHeroes room for supers only!*/        PubNub.ngGrant({          channel: 'SuperHeroes',          auth_key: $rootScope.authKey,          read: true,          write: true,          callback: function() {            return console.log('SuperHeroes! all set', arguments);          }        });        PubNub.ngGrant({          channel: "SuperHeroes-pnpres",          auth_key: $rootScope.authKey,          read: true,          write: false,          callback: function() {            return console.log('SuperHeroes! presence all set', arguments);          }        });        PubNub.ngGrant({          channel: '__controlchannel',          read: true,          write: true,          callback: function() {            return console.log('control channel all set', arguments);          }        });        PubNub.ngGrant({          channel: '__controlchannel-pnpres',          read: true,          write: false,          callback: function() {            return console.log('control channel presence all set', arguments);          }        });      }		if(PubNub.initialized()){		}	};    var _ref;    if (!PubNub.initialized()) {      $scope.join();    }    /* Use a "control channel" to collect channel creation messages*/    $scope.controlChannel = '__controlchannel';    $scope.channels = [];    /* Publish a chat message*/    $scope.publish = function() {      if (!$scope.selectedChannel) {        return;      }	  console.log(PubNub._channels.length);	  debugger;      PubNub.ngPublish({        channel: $scope.selectedChannel,        message: {          text: $scope.newMessage,          user: $cookies.currentUserName        }      });      return $scope.newMessage = '';    };    /* Create a new channel*/    $scope.createChannel = function(newChannel) {      var channel;      // if (!($scope.data["super"] && $scope.newChannel)) {        // return;      // }	  $scope.newChannel = newChannel;      channel = $scope.newChannel;      $scope.newChannel = '';      PubNub.ngGrant({        channel: channel,        read: true,        write: true,        callback: function() {          return console.log("" + channel + " all set", arguments);        }      });      PubNub.ngGrant({        channel: "" + channel + "-pnpres",        read: true,        write: false,        callback: function() {          return console.log("" + channel + " presence all set", arguments);        }      });      PubNub.ngPublish({        channel: $scope.controlChannel,        message: channel      });      return setTimeout(function() {        $scope.subscribe(channel);        return $scope.showCreate = false;      }, 100);	  $scope.subscribe(channel);    };    /* Select a channel to display chat history & presence*/    $scope.subscribe = function(channel) {      var _ref;      console.log('subscribe', channel);      if (channel === $scope.selectedChannel) {        return;      }      if ($scope.selectedChannel) {        PubNub.ngUnsubscribe({          channel: $scope.selectedChannel        });      }      $scope.selectedChannel = channel;      $scope.messages = ['Welcome to ColabMe'];      PubNub.ngSubscribe({        channel: $scope.selectedChannel,		secret_key: $rootScope.secretKey,        auth_key: $scope.authKey,        error: function() {          return console.log(arguments);        }      });      $rootScope.$on(PubNub.ngPrsEv($scope.selectedChannel), function(ngEvent, payload) {        return $scope.$apply(function() {          var newData, userData;          userData = PubNub.ngPresenceData($scope.selectedChannel);          newData = {};          $scope.users = PubNub.map(PubNub.ngListPresence($scope.selectedChannel), function(x) {            var newX;            newX = x;            if (x.replace) {              newX = x.replace(/\w+__/, "");            }            if (x.uuid) {              newX = x.uuid.replace(/\w+__/, "");            }            newData[newX] = userData[x] || {};            return newX;          });          return $scope.userData = newData;        });      });      PubNub.ngHereNow({        channel: $scope.selectedChannel      });      $rootScope.$on(PubNub.ngMsgEv($scope.selectedChannel), function(ngEvent, payload) {        var msg;		//alert(payload.message.user + ' ' +  $cookies.currentUsername);		if(payload.message.user){			var users = payload.message.user;			var text =  payload.message.text;			var message = payload.message;			//if($cookies.currentUserName == 'Rishabh'){				//$scope.users = payload.message.user;				msg = users ? "[" + users + "] " + text : "[unknown] " + message;				console.log('Cookies User ' + $cookies.currentUserName + ' - ' + users + ' Users  ' + msg + ' - Msg');				return $scope.$apply(function() {					return $scope.messages.unshift({'message': msg, 'user': users});				});			//}			// else{				// if(payload.message.user == $cookies.currentUserName || payload.message.user == 'Rishabh'){					// msg = users ? "[" + users + "]  " + text : "[unknown] " + message;					// console.log('Cookies User - ' + users + ' Users  ' + msg + ' - Msg');					// return $scope.$apply(function() {						// return $scope.messages.unshift({'message': msg, 'user': users});					// });				// }			// }		}      });      return PubNub.ngHistory({        channel: $scope.selectedChannel,        auth_key: $scope.authKey,        count: 500      });    };    /* When controller initializes, subscribe to retrieve channels from "control channel"*/    PubNub.ngSubscribe({      channel: $scope.controlChannel    });    /* Register for channel creation message events*/    $rootScope.$on(PubNub.ngMsgEv($scope.controlChannel), function(ngEvent, payload) {      return $scope.$apply(function() {        if ($scope.channels.indexOf(payload.message) < 0) {          return $scope.channels.push(payload.message);        }      });    });    /* Get a reasonable historical backlog of messages to populate the channels list*/    PubNub.ngHistory({      channel: $scope.controlChannel,      count: 500    });    /* and finally, create and/or enter the 'WaitingRoom' channel*/    if ((_ref = $scope.data) != null ? _ref["super"] : void 0) {      $scope.newChannel = 'WaitingRoom';      return $scope.createChannel();    } else {		if(PubNub._channels.length > 0){			if(PubNub._channels.indexOf($stateParams.moodboardId) === -1){				$scope.createChannel($stateParams.moodboardId);			}			else{				$scope.subscribe($stateParams.moodboardId);			}		}      //return $scope.subscribe('WaitingRoom');    }  }).controller('AddChatTaskCtrl', function ($scope, $modalInstance, TaskService, message, pageId, userAccounts) {  	  alert(message);	  $scope.taskDescription = message;	  $scope.userAccounts = userAccounts;	  $scope.pageId = pageId;	  $scope.userAccount = {};	  $scope.addTask = function() {	  		alert('Inside Task');				console.log('Description - ' + $scope.taskDescription + '<br/> Selected Id - ' + $scope.userAccount.selected.id + '<br/> PageId - ' + $scope.pageId);		TaskService.addTask($scope.taskDescription,$scope.userAccount.selected.id,$scope.pageId);		$scope.taskDescription = '';		$scope.showTask = false;	};	  $scope.ok = function () {		$modalInstance.close();	  };	  $scope.cancel = function () {		$modalInstance.dismiss('cancel');	  };});